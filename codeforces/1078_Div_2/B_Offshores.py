import sys

input = lambda: sys.stdin.readline().rstrip()

# 교환마다 (x - y) 만큼 감소
# 한 군데에 전부 몰 수 있는 것이 아니라면 교환 횟수 최대한 적게
# 근데 한 군데에 전부 모는 것이 최적해인가?
# 아니면 교환 횟수를 적게 하는게 최적해인가?

# 추가 교환이 없다는 가정하에 i 은행에서 돈을 옮길 수 있는 횟수: a_i // x

# 10 9 8 7 -> 25 + 9 => 9회 교환
# 14 4 8 7
# 18 4 3 7
# 22 4 3 2

# 5 13 8 7
# 0 17 8 7
# 0 21 3 7
# 0 25 3 2 -> 4회 교환, 이것도 가능

# tc1 한군데에 전부 모는 것과 교환횟수를 적게 했을 때의 결과는 동일
# 다른 TC도 검증 필요
# 증명
# 송금 x 감소, 수금 y 증가 (y <= x)
# k 은행에 모은다
# 1. k에서 외부로 유출했다가 다시 모으는 경우는 감소만 시키므로 좋지 않음
# 2. 중간 경유가 최적해가 아님 왜?
# i -> k로 보낼 때 j를 간다고 생각
# i -> j -> k 이면
#   i -> j: i - x, j + y; j -> k: j - x, k + y
#   i -> k; i - x, k + y와 근본적으로 동일함; j를 굳이 거칠 이유가 없음
# 혹시 j에 남는 수가 x보다 작다 하더라도 사실상 동일. 오히려 전체 돈에서 (x - y)만큼 줄어들기 때문에 손해

# 결론
# 은행 n개에 각각 최대로 모을 수 있는 값을 구하고 그 최댓값 출력
# 그 수식
# a_i + y * sum(a_j // x) -> 자기 자신 제외한 a_t//x의 합 -> 미리 구해서 자기만 빼서 더하자

# main code
t = int(input())

for _ in range(t):
    n, x, y = map(int, input().split())
    a = [*map(int, input().split())]

    s = 0
    for aa in a:
        s += aa // x
    
    res = 0
    for aa in a:
        tmp = aa + y * (s - aa // x)
        if res < tmp:
            res = tmp
    print(res)
